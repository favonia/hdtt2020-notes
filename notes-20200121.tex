\documentclass[11pt]{article}
\usepackage{hdtt2020}
\usepackage{newpxmath}
\usepackage{newpxtext}

\NewDocumentCommand{\JJ}{}{\mathcal{J}}

\title{CSCI 8980 Higher-Dimensional Type Theory\\ Lecture Notes}
\author{Favonia}
\date{January \{21,28\}, 2020}

\begin{document}

\maketitle

\section{Principles of Type Theory}

Type theory serves as a foundation of mathematics alternative to set theory. Although it is difficult to pin down a precise definition of type theory, we have pretty good ideas about what principles a type theory should follow. Here are two important principles:
\begin{enumerate}
  \item Type theory is about \textbf{abstractions.}

    Type theory comes with built-in abstractions. For example, in many type theories with natural numbers, the number zero and the successor operator are primitive notions, not defined in terms of other more ``basic'' notions; in contrast, all numbers and operators are encoded as sets in set theory. Type theory is arguably closer to how mathematicians actually work in practice: for example, a reasonable proof in number theory should not depend on how natural numbers are encoded. Type theory formally enforces such abstractions.

    One may draw an analogy from Euclid's famous book Elements, which starts with abstract notions of points and lines without using the Cartesian coordinates. The Homotopy Type Theory, which we will introduce in this semester, can be seen as abstractions of topological spaces up to continuous deformations without using point topology.

  \item Type theory is about \textbf{constructions.}

    Another important feature of most type theories is to treat \emph{being true} as \emph{having a proof}. We pay close attention to how proofs are constructed. There are two significant consequences of this principle:
    \begin{itemize}
      \item Type theory works well for computer science. The types are specifications and proofs are programs. It is not surprising that almost every programming language employs some type system to classify its programs.

      \item The global law of excluded middle (LEM) (which means, for any formula $A$, either $A$ or $\neg A$) no longer makes sense, because it is unreasonable to assume a procedure that can give either a proof or a refutation for any type $A$. The $A$ can be the Riemann Hypothesis. That said, for specific $A$, say, whether two natural numbers are equal, we can either prove $A$ or refute $A$ because the equality can be determined algorithmically.
    \end{itemize}
\end{enumerate}
Note that, even though the global LEM is usually not valid in a type theory, we can show the law is \emph{irrefutable} ($\neg \neg \parens{\sumtype{A}{\neg A}}$), which means while we cannot prove a global LEM, we cannot refute it either.\footnote{This is a difficult theorem that you should try to prove in Agda.}

\section{How to Define a Type Theory?}

\subsection{Judgments}

\emph{Judgments} represent the knowledge in a type theory.
They encode mathematical statements such that ``$\lam{x}[A]{x}$ is of type $A \to A$.''
For now, we will focus on the following four basic judgment forms:

\begin{center}
  \begin{tabular}{ll}
    \toprule
    Basic Judgments & Meanings \\
    \midrule
    $\istype{A}$ & $A$ is a type \\
    $\eqtype{A}{B}$ & $A$ and $B$ are equal types \\
    $\oftype{M}{A}$ & $M$ is an element of type $A$ \\
    $\eqterm{M}{N}{A}$ & $M$ and $N$ are the same element of type $A$ \\
    \bottomrule
  \end{tabular}
\end{center}

We can then define \emph{hypothetical} judgements, which are basic judgments parametrized by variables.
The collection of available variables form the \emph{context}.
Formally, a context is a list of hypotheses, i.e., variables annotated with their types,%
\footnote{We will introduce new forms of hypotheses in the later part of this course.}
\[
  x_1{:}A_1, x_1{:}A_2, \cdots, x_n{:}A_n
\]
which says variable $x_i$ is of type $A_i$.
A hypothetical judgment takes the following form:
\[
  \entails{x_1{:}A_1, x_1{:}A_2, \cdots, x_n{:}A_n}{\JJ}
\]
which says $\JJ$ holds under the hypotheses $x_1{:}A_1, x_1{:}A_2, \cdots, x_n{:}A_n$.
As a special case, $\emptyctx$ is the empty context and
\[
  \entails{\emptyctx}{\JJ}
\]
emphasizes that $\JJ$ holds with access to no variables.

\subsection{Inference Rules}

A type theory is specified by a collection of \emph{inference rules},
which represent all the valid reasoning steps in the theory.
To start with, a type theory might have this rule:
\[
  \begin{prooftree}
    \hypo{\eqtype{A}{B}}
    \infer1{\eqtype{B}{A}}
  \end{prooftree}
\]
which states the symmetry of type equality.
It might also have this one:
\[
  \begin{prooftree}
    \hypo{\istype{A}}
    \infer1{\eqtype{A}{A}}
  \end{prooftree}
\]
which states every type is equal to itself.
The general form of an inference rule consists of a finite number of premises and one conclusion,
separated by a horizontal line as follows:
\[
  \begin{prooftree}
    \hypo{\JJ_1}
    \hypo{\JJ_2}
    \hypo{\cdots}
    \hypo{\JJ_n}
    \infer4[(rule name)]{\JJ}
  \end{prooftree}
\]
It means that, if the premises $\JJ_1, \JJ_2, \cdots, \JJ_n$ are valid, then the conclusion $\JJ$ is valid, too.
If we manage to prove a judgment $\JJ$ using the inference rules in a type theory,
the history of the reasoning may be represented as a tree, which is called \emph{derivation}.
For example, a possible derivation is as follows:
\[
  \begin{prooftree}
    \infer0{\istype{\unittype}}
    \infer1{\eqtype{\unittype}{\unittype}}
  \end{prooftree}
\]
We say a judgment $\JJ$ is \emph{derivable} if there is a complete derivation tree whose root (the bottommost judgment) is the judgment $\JJ$.

\section{Structural Rules}

\section{How to Define a Type?}

Since type theory is about abstractions, there will be many types capturing different abstractions. To define types, one should answer the following five questions:

\begin{enumerate}
  \item Formation: What are the types?
  \item Introduction: What are the canonical ways to construct elements in the types?
  \item Elimination: How to use an element of those types?
  \item Computation: What will happen when you are using elements constructed using the canonical ways?
  \item Uniqueness: Is any element equal to some element constructed in one of the canonical ways?
    (This is optional.)
\end{enumerate}

\section{Basic Types}

\section{Categorical Aspects}

\end{document}
